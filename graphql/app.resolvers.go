package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"errors"
	"strconv"
	"time"

	"encore.app/app"
	"encore.app/app/middleware"
	"encore.app/app/repositories"
	"encore.app/app/services"
	"encore.app/app/utils"
	"encore.app/graphql/generated"
	"encore.app/graphql/model"
	"gorm.io/gorm"
)

// ID is the resolver for the id field.
func (r *blogResolver) ID(ctx context.Context, obj *app.Blog) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// PublishedAt is the resolver for the publishedAt field.
func (r *blogResolver) PublishedAt(ctx context.Context, obj *app.Blog) (*string, error) {
	return utils.FormatTimePtr(obj.PublishedAt), nil
}

// Tags is the resolver for the tags field.
func (r *blogResolver) Tags(ctx context.Context, obj *app.Blog) ([]string, error) {
	return []string(obj.Tags), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *blogResolver) CreatedAt(ctx context.Context, obj *app.Blog) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *blogResolver) UpdatedAt(ctx context.Context, obj *app.Blog) (string, error) {
	return utils.FormatTime(obj.UpdatedAt), nil
}

// ID is the resolver for the id field.
func (r *categoryResolver) ID(ctx context.Context, obj *app.Category) (string, error) {
	return utils.FormatID(obj.ID), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *categoryResolver) CreatedAt(ctx context.Context, obj *app.Category) (string, error) {
	return utils.FormatTime(obj.CreatedAt), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *categoryResolver) UpdatedAt(ctx context.Context, obj *app.Category) (string, error) {
	return utils.FormatTime(obj.UpdatedAt), nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.LoginResponse, error) {
	authService := r.services.Auth
	if authService == nil {
		return nil, errors.New("auth service not available")
	}

	loginReq := &services.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
	}

	result, err := authService.Login(ctx, loginReq)
	if err != nil {
		return nil, err
	}

	return &model.LoginResponse{
		User: result.User,
		Tokens: &model.TokenPair{
			AccessToken:  result.Tokens.AccessToken,
			RefreshToken: result.Tokens.RefreshToken,
			ExpiresIn:    int(result.Tokens.ExpiresIn),
			TokenType:    result.Tokens.TokenType,
		},
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.LoginResponse, error) {
	authService := r.services.Auth
	if authService == nil {
		return nil, errors.New("auth service not available")
	}

	var role app.UserRole
	if input.Role != nil {
		role = *input.Role
	}

	registerReq := &services.RegisterRequest{
		Name:     input.Name,
		Email:    input.Email,
		Password: input.Password,
		Role:     role,
	}

	result, err := authService.Register(ctx, registerReq)
	if err != nil {
		return nil, err
	}

	return &model.LoginResponse{
		User: result.User,
		Tokens: &model.TokenPair{
			AccessToken:  result.Tokens.AccessToken,
			RefreshToken: result.Tokens.RefreshToken,
			ExpiresIn:    int(result.Tokens.ExpiresIn),
			TokenType:    result.Tokens.TokenType,
		},
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.TokenPair, error) {
	authService := r.services.Auth
	if authService == nil {
		return nil, errors.New("auth service not available")
	}

	tokens, err := authService.RefreshToken(ctx, refreshToken)
	if err != nil {
		return nil, err
	}

	return &model.TokenPair{
		AccessToken:  tokens.AccessToken,
		RefreshToken: tokens.RefreshToken,
		ExpiresIn:    int(tokens.ExpiresIn),
		TokenType:    tokens.TokenType,
	}, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, input model.ChangePasswordInput) (bool, error) {
	// Get auth token from headers
	authHeader := utils.GetAuthHeaderFromContext(ctx)
	claims, err := middleware.RequireAuth(ctx, authHeader)
	if err != nil {
		return false, err
	}

	authService := r.services.Auth
	if authService == nil {
		return false, errors.New("auth service not available")
	}

	err = authService.ChangePassword(ctx, claims.UserID, input.OldPassword, input.NewPassword)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateUserRole is the resolver for the updateUserRole field.
func (r *mutationResolver) UpdateUserRole(ctx context.Context, userID string, role app.UserRole) (*app.User, error) {
	// Get auth token from headers
	authHeader := utils.GetAuthHeaderFromContext(ctx)
	claims, err := middleware.RequireAuth(ctx, authHeader)
	if err != nil {
		return nil, err
	}

	// Require admin role
	if err := middleware.RequireRole(claims, app.UserRoleAdmin); err != nil {
		return nil, err
	}

	id, err := utils.StringToUint(userID)
	if err != nil {
		return nil, errors.New("invalid user ID")
	}

	authService := r.services.Auth
	if authService == nil {
		return nil, errors.New("auth service not available")
	}

	err = authService.UpdateUserRole(ctx, id, role)
	if err != nil {
		return nil, err
	}

	// Get updated user
	updatedUser, err := authService.GetUserByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return updatedUser, nil
}

// DeactivateUser is the resolver for the deactivateUser field.
func (r *mutationResolver) DeactivateUser(ctx context.Context, userID string) (bool, error) {
	// Get auth token from headers
	authHeader := utils.GetAuthHeaderFromContext(ctx)
	claims, err := middleware.RequireAuth(ctx, authHeader)
	if err != nil {
		return false, err
	}

	// Require admin role
	if err := middleware.RequireRole(claims, app.UserRoleAdmin); err != nil {
		return false, err
	}

	id, err := utils.StringToUint(userID)
	if err != nil {
		return false, errors.New("invalid user ID")
	}

	authService := r.services.Auth
	if authService == nil {
		return false, errors.New("auth service not available")
	}

	err = authService.DeactivateUser(ctx, id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*app.User, error) {
	user, err := r.services.User.CreateUser(ctx, input.Name, input.Email)
	if err != nil {
		return nil, utils.HandleRepositoryError(err, "user")
	}
	return user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*app.User, error) {
	userID, err := utils.ParseID(id)
	if err != nil {
		return nil, err
	}
	user, err := r.services.User.UpdateUser(ctx, userID, input.Name, input.Email)
	if err != nil {
		return nil, utils.HandleRepositoryError(err, "user")
	}
	return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	userID, err := utils.ParseID(id)
	if err != nil {
		return false, err
	}
	err = r.services.User.DeleteUser(ctx, userID)
	if err != nil {
		return false, utils.HandleRepositoryError(err, "user")
	}
	return true, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*app.Category, error) {
	// Require admin authentication
	_, err := RequireAuthWithRole(ctx, app.UserRoleAdmin)
	if err != nil {
		return nil, err
	}

	// Extract optional description
	description := ExtractOptionalString(input.Description)

	// Create category
	category, err := r.services.Category.CreateCategory(ctx, input.Name, description)
	if err != nil {
		return nil, err
	}

	return category, nil
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, id string, input model.UpdateCategoryInput) (*app.Category, error) {
	// Require admin authentication
	_, err := RequireAuthWithRole(ctx, app.UserRoleAdmin)
	if err != nil {
		return nil, err
	}

	// Parse category ID
	categoryID, err := utils.ParseID(id)
	if err != nil {
		return nil, err
	}

	// Update category
	category, err := r.services.Category.UpdateCategory(ctx, categoryID, input.Name, input.Description)
	if err != nil {
		return nil, err
	}

	return category, nil
}

// DeleteCategory is the resolver for the deleteCategory field.
func (r *mutationResolver) DeleteCategory(ctx context.Context, id string) (bool, error) {
	// Require admin authentication
	_, err := RequireAuthWithRole(ctx, app.UserRoleAdmin)
	if err != nil {
		return false, err
	}

	// Parse category ID
	categoryID, err := utils.ParseID(id)
	if err != nil {
		return false, err
	}

	// Delete category
	if err := r.services.Category.DeleteCategory(ctx, categoryID); err != nil {
		return false, err
	}

	return true, nil
}

// CreateResumeContent is the resolver for the createResumeContent field.
func (r *mutationResolver) CreateResumeContent(ctx context.Context, input model.CreateResumeContentInput) (*app.ResumeContent, error) {
	categoryID, err := strconv.ParseUint(input.CategoryID, 10, 32)
	if err != nil {
		return nil, errors.New("invalid category ID")
	}

	description := ""
	if input.Description != nil {
		description = *input.Description
	}

	detail := ""
	if input.Detail != nil {
		detail = *input.Detail
	}

	resumeContent, err := r.services.ResumeContent.CreateResumeContent(ctx, input.Title, description, detail, uint(categoryID))
	if err != nil {
		return nil, err
	}
	return resumeContent, nil
}

// UpdateResumeContent is the resolver for the updateResumeContent field.
func (r *mutationResolver) UpdateResumeContent(ctx context.Context, id string, input model.UpdateResumeContentInput) (*app.ResumeContent, error) {
	resumeContentID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, errors.New("invalid resume content ID")
	}

	var categoryID *uint = nil
	if input.CategoryID != nil {
		cID, err := strconv.ParseUint(*input.CategoryID, 10, 32)
		if err != nil {
			return nil, errors.New("invalid category ID")
		}
		categoryIDVal := uint(cID)
		categoryID = &categoryIDVal
	}

	resumeContent, err := r.services.ResumeContent.UpdateResumeContent(ctx, uint(resumeContentID), input.Title, input.Description, input.Detail, categoryID)
	if err != nil {
		return nil, err
	}
	return resumeContent, nil
}

// DeleteResumeContent is the resolver for the deleteResumeContent field.
func (r *mutationResolver) DeleteResumeContent(ctx context.Context, id string) (bool, error) {
	resumeContentID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return false, errors.New("invalid resume content ID")
	}

	err = r.services.ResumeContent.DeleteResumeContent(ctx, uint(resumeContentID))
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input model.CreateProjectInput) (*app.Project, error) {
	// Require editor authentication
	authResult, err := RequireAuthWithRole(ctx, app.UserRoleEditor)
	if err != nil {
		return nil, err
	}

	// Determine target user ID with permission check
	userID, err := r.determineProjectUserID(input.UserID, authResult)
	if err != nil {
		return nil, err
	}

	// Extract optional description
	description := ExtractOptionalString(input.Description)

	// Create project
	project, err := r.services.Project.CreateProject(ctx, input.Title, description, userID)
	if err != nil {
		return nil, utils.HandleRepositoryError(err, "project")
	}

	return project, nil
}

// determineProjectUserID determines the user ID for project with permission checks
func (r *mutationResolver) determineProjectUserID(inputUserID *string, authResult *AuthResult) (*uint, error) {
	if inputUserID == nil {
		// Default to current user
		return &authResult.UserID, nil
	}

	// Parse requested user ID
	parsed, err := utils.ParseID(*inputUserID)
	if err != nil {
		return nil, err
	}

	// Only admin can create projects for other users
	if authResult.Claims.Role != app.UserRoleAdmin && parsed != authResult.UserID {
		return nil, errors.New("insufficient permissions to create project for another user")
	}

	return &parsed, nil
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id string, input model.UpdateProjectInput) (*app.Project, error) {
	// Parse project ID
	projectID, err := utils.ParseID(id)
	if err != nil {
		return nil, err
	}

	// Parse optional user ID
	var userID *uint
	if input.UserID != nil {
		parsed, err := utils.ParseID(*input.UserID)
		if err != nil {
			return nil, err
		}
		userID = &parsed
	}

	// Update project
	project, err := r.services.Project.UpdateProject(ctx, projectID, input.Title, input.Description, userID)
	if err != nil {
		return nil, utils.HandleRepositoryError(err, "project")
	}

	return project, nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id string) (bool, error) {
	// Parse project ID
	projectID, err := utils.ParseID(id)
	if err != nil {
		return false, err
	}

	// Delete project using service layer
	if err := r.services.Project.DeleteProject(ctx, projectID); err != nil {
		return false, err
	}

	return true, nil
}

// CreateBlog is the resolver for the createBlog field.
func (r *mutationResolver) CreateBlog(ctx context.Context, input model.CreateBlogInput) (*app.Blog, error) {
	// Require editor authentication
	authResult, err := RequireAuthWithRole(ctx, app.UserRoleEditor)
	if err != nil {
		return nil, err
	}

	// Determine author
	author := r.determineBlogAuthor(ctx, input.Author, authResult.UserID)

	// Set default status if not provided
	status := app.BlogStatusDraft
	if input.Status != nil {
		status = *input.Status
	}

	// Extract optional fields
	summary := ExtractOptionalString(input.Summary)
	metaDescription := ExtractOptionalString(input.MetaDescription)
	tags := ExtractOptionalStringSlice(input.Tags)

	// Create blog
	blog, err := r.services.Blog.CreateBlog(ctx, input.Title, input.Content, summary, input.Slug, author, metaDescription, status, tags)
	if err != nil {
		return nil, err
	}

	return blog, nil
}

// determineBlogAuthor determines the author for a blog post
func (r *mutationResolver) determineBlogAuthor(ctx context.Context, inputAuthor *string, userID uint) string {
	if inputAuthor != nil {
		return *inputAuthor
	}

	// Get current user info as fallback
	if authService := r.services.Auth; authService != nil {
		if user, err := authService.GetCurrentUser(ctx, userID); err == nil {
			return user.Name
		}
	}

	return ""
}

// UpdateBlog is the resolver for the updateBlog field.
func (r *mutationResolver) UpdateBlog(ctx context.Context, id string, input model.UpdateBlogInput) (*app.Blog, error) {
	// Parse blog ID
	blogID, err := utils.ParseID(id)
	if err != nil {
		return nil, err
	}

	// Prepare tags pointer
	var tags *[]string
	if input.Tags != nil {
		tags = &input.Tags
	}

	// Update blog using service layer
	blog, err := r.services.Blog.UpdateBlog(ctx, blogID, input.Title, input.Content, input.Summary, input.Slug, input.Author, input.MetaDescription, input.Status, tags)
	if err != nil {
		return nil, err
	}

	return blog, nil
}

// DeleteBlog is the resolver for the deleteBlog field.
func (r *mutationResolver) DeleteBlog(ctx context.Context, id string) (bool, error) {
	// Parse blog ID
	blogID, err := utils.ParseID(id)
	if err != nil {
		return false, err
	}

	// Delete blog using service layer
	if err := r.services.Blog.DeleteBlog(ctx, blogID); err != nil {
		return false, err
	}

	return true, nil
}

// ID is the resolver for the id field.
func (r *projectResolver) ID(ctx context.Context, obj *app.Project) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// UserID is the resolver for the userID field.
func (r *projectResolver) UserID(ctx context.Context, obj *app.Project) (*string, error) {
	if obj.UserID == nil {
		return nil, nil
	}
	userIDStr := utils.FormatID(*obj.UserID)
	return &userIDStr, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *projectResolver) CreatedAt(ctx context.Context, obj *app.Project) (string, error) {
	return utils.FormatTime(obj.CreatedAt), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *projectResolver) UpdatedAt(ctx context.Context, obj *app.Project) (string, error) {
	return utils.FormatTime(obj.UpdatedAt), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*app.User, error) {
	// Get auth token from headers
	authHeader := utils.GetAuthHeaderFromContext(ctx)
	claims, err := middleware.RequireAuth(ctx, authHeader)
	if err != nil {
		return nil, err
	}

	authService := r.services.Auth
	if authService == nil {
		return nil, errors.New("auth service not available")
	}

	user, err := authService.GetCurrentUser(ctx, claims.UserID)
	if err != nil {
		return nil, err
	}

	return user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, page *int, pageSize *int, sortBy *string, sortDirection *model.SortDirection) (*model.UserConnection, error) {
	// Set defaults
	pageNum := 1
	if page != nil {
		pageNum = *page
	}
	pageSizeNum := 10
	if pageSize != nil {
		pageSizeNum = *pageSize
	}
	sortByStr := "createdAt"
	if sortBy != nil {
		sortByStr = *sortBy
	}

	params := utils.ValidatePaginationParams(pageNum, pageSizeNum, sortByStr)
	if sortDirection != nil && *sortDirection == model.SortDirectionAsc {
		params.SortDesc = false
	}

	result, err := r.services.User.ListUsers(ctx, params)
	if err != nil {
		return nil, utils.HandleRepositoryError(err, "users")
	}

	return &model.UserConnection{
		Data: utils.ToPointerSlice(result.Data),
		Pagination: &model.PaginationInfo{
			Page:       result.Page,
			PageSize:   result.PageSize,
			Total:      int(result.Total),
			TotalPages: result.TotalPages,
		},
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*app.User, error) {
	userID, err := utils.ParseID(id)
	if err != nil {
		return nil, err
	}
	user, err := r.services.User.GetUser(ctx, userID)
	if err != nil {
		return nil, utils.HandleRepositoryError(err, "user")
	}
	return user, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, page *int, pageSize *int, sortBy *string, sortDirection *model.SortDirection) (*model.CategoryConnection, error) {
	params := repositories.PaginationParams{
		Page:     1,
		PageSize: 10,
	}

	if page != nil && *page > 0 {
		params.Page = *page
	}
	if pageSize != nil && *pageSize > 0 {
		params.PageSize = *pageSize
	}
	if sortBy != nil {
		params.SortBy = *sortBy
	}
	if sortDirection != nil && *sortDirection == model.SortDirectionDesc {
		params.SortDesc = true
	}

	result, err := r.services.Category.ListCategories(ctx, params)
	if err != nil {
		return nil, err
	}

	// Convert to CategoryConnection
	data := make([]*app.Category, len(result.Data))
	for i, category := range result.Data {
		data[i] = &category
	}

	return &model.CategoryConnection{
		Data: data,
		Pagination: &model.PaginationInfo{
			Page:       result.Page,
			TotalPages: result.TotalPages,
			Total:      int(result.Total),
			PageSize:   result.PageSize,
		},
	}, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id string) (*app.Category, error) {
	categoryID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, errors.New("invalid category ID")
	}

	category, err := r.services.Category.GetCategory(ctx, uint(categoryID))
	if err != nil {
		return nil, err
	}
	return category, nil
}

// ResumeContents is the resolver for the resumeContents field.
func (r *queryResolver) ResumeContents(ctx context.Context, page *int, pageSize *int, sortBy *string, sortDirection *model.SortDirection) (*model.ResumeContentConnection, error) {
	params := repositories.PaginationParams{
		Page:     1,
		PageSize: 10,
	}

	if page != nil && *page > 0 {
		params.Page = *page
	}
	if pageSize != nil && *pageSize > 0 {
		params.PageSize = *pageSize
	}
	if sortBy != nil {
		params.SortBy = *sortBy
	}
	if sortDirection != nil && *sortDirection == model.SortDirectionDesc {
		params.SortDesc = true
	}

	result, err := r.services.ResumeContent.ListResumeContents(ctx, params)
	if err != nil {
		return nil, err
	}

	// Convert to ResumeContentConnection
	data := make([]*app.ResumeContent, len(result.Data))
	for i, resumeContent := range result.Data {
		data[i] = &resumeContent
	}

	return &model.ResumeContentConnection{
		Data: data,
		Pagination: &model.PaginationInfo{
			Page:       result.Page,
			TotalPages: result.TotalPages,
			Total:      int(result.Total),
			PageSize:   result.PageSize,
		},
	}, nil
}

// ResumeContent is the resolver for the resumeContent field.
func (r *queryResolver) ResumeContent(ctx context.Context, id string) (*app.ResumeContent, error) {
	resumeContentID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, errors.New("invalid resume content ID")
	}

	resumeContent, err := r.services.ResumeContent.GetResumeContent(ctx, uint(resumeContentID))
	if err != nil {
		return nil, err
	}
	return resumeContent, nil
}

// ResumeContentsByCategory is the resolver for the resumeContentsByCategory field.
func (r *queryResolver) ResumeContentsByCategory(ctx context.Context, categoryID string, page *int, pageSize *int, sortBy *string, sortDirection *model.SortDirection) (*model.ResumeContentConnection, error) {
	catID, err := strconv.ParseUint(categoryID, 10, 32)
	if err != nil {
		return nil, errors.New("invalid category ID")
	}

	params := repositories.PaginationParams{
		Page:     1,
		PageSize: 10,
	}

	if page != nil && *page > 0 {
		params.Page = *page
	}
	if pageSize != nil && *pageSize > 0 {
		params.PageSize = *pageSize
	}
	if sortBy != nil {
		params.SortBy = *sortBy
	}
	if sortDirection != nil && *sortDirection == model.SortDirectionDesc {
		params.SortDesc = true
	}

	result, err := r.services.ResumeContent.ListResumeContentsByCategory(ctx, uint(catID), params)
	if err != nil {
		return nil, err
	}

	// Convert to ResumeContentConnection
	data := make([]*app.ResumeContent, len(result.Data))
	for i, resumeContent := range result.Data {
		data[i] = &resumeContent
	}

	return &model.ResumeContentConnection{
		Data: data,
		Pagination: &model.PaginationInfo{
			Page:       result.Page,
			TotalPages: result.TotalPages,
			Total:      int(result.Total),
			PageSize:   result.PageSize,
		},
	}, nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, page *int, pageSize *int, sortBy *string, sortDirection *model.SortDirection) (*model.ProjectConnection, error) {
	// Set defaults
	pageNum := 1
	if page != nil {
		pageNum = *page
	}
	pageSizeNum := 10
	if pageSize != nil {
		pageSizeNum = *pageSize
	}
	sortByStr := "createdAt"
	if sortBy != nil {
		sortByStr = *sortBy
	}

	params := utils.ValidatePaginationParams(pageNum, pageSizeNum, sortByStr)
	if sortDirection != nil && *sortDirection == model.SortDirectionAsc {
		params.SortDesc = false
	}

	result, err := r.services.Project.ListProjects(ctx, params)
	if err != nil {
		return nil, utils.HandleRepositoryError(err, "projects")
	}

	return &model.ProjectConnection{
		Data: utils.ToPointerSlice(result.Data),
		Pagination: &model.PaginationInfo{
			Page:       result.Page,
			PageSize:   result.PageSize,
			Total:      int(result.Total),
			TotalPages: result.TotalPages,
		},
	}, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*app.Project, error) {
	projectID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, err
	}
	var project app.Project
	if err := r.db.First(&project, projectID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &project, nil
}

// ProjectsByUser is the resolver for the projectsByUser field.
func (r *queryResolver) ProjectsByUser(ctx context.Context, userID string, page *int, pageSize *int, sortBy *string, sortDirection *model.SortDirection) (*model.ProjectConnection, error) {
	uID, err := strconv.ParseUint(userID, 10, 32)
	if err != nil {
		return nil, errors.New("invalid user ID")
	}

	params := repositories.PaginationParams{
		Page:     1,
		PageSize: 10,
	}

	if page != nil && *page > 0 {
		params.Page = *page
	}
	if pageSize != nil && *pageSize > 0 {
		params.PageSize = *pageSize
	}
	if sortBy != nil {
		params.SortBy = *sortBy
	}
	if sortDirection != nil && *sortDirection == model.SortDirectionDesc {
		params.SortDesc = true
	}

	result, err := r.services.Project.ListProjectsByUser(ctx, uint(uID), params)
	if err != nil {
		return nil, err
	}

	// Convert to ProjectConnection
	data := make([]*app.Project, len(result.Data))
	for i, project := range result.Data {
		data[i] = &project
	}

	return &model.ProjectConnection{
		Data: data,
		Pagination: &model.PaginationInfo{
			Page:       result.Page,
			TotalPages: result.TotalPages,
			Total:      int(result.Total),
			PageSize:   result.PageSize,
		},
	}, nil
}

// Blogs is the resolver for the blogs field.
func (r *queryResolver) Blogs(ctx context.Context, page *int, pageSize *int, sortBy *string, sortDirection *model.SortDirection) (*model.BlogConnection, error) {
	// Set defaults
	pageNum := 1
	if page != nil {
		pageNum = *page
	}
	pageSizeNum := 10
	if pageSize != nil {
		pageSizeNum = *pageSize
	}
	sortByStr := "createdAt"
	if sortBy != nil {
		sortByStr = *sortBy
	}

	params := utils.ValidatePaginationParams(pageNum, pageSizeNum, sortByStr)
	if sortDirection != nil && *sortDirection == model.SortDirectionAsc {
		params.SortDesc = false
	}

	result, err := r.services.Blog.ListBlogs(ctx, params)
	if err != nil {
		return nil, utils.HandleRepositoryError(err, "blogs")
	}

	return &model.BlogConnection{
		Data: utils.ToPointerSlice(result.Data),
		Pagination: &model.PaginationInfo{
			Page:       result.Page,
			PageSize:   result.PageSize,
			Total:      int(result.Total),
			TotalPages: result.TotalPages,
		},
	}, nil
}

// Blog is the resolver for the blog field.
func (r *queryResolver) Blog(ctx context.Context, id string) (*app.Blog, error) {
	blogID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, err
	}
	var blog app.Blog
	if err := r.db.First(&blog, blogID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &blog, nil
}

// BlogBySlug is the resolver for the blogBySlug field.
func (r *queryResolver) BlogBySlug(ctx context.Context, slug string) (*app.Blog, error) {
	blog, err := r.services.Blog.GetBlogBySlug(ctx, slug)
	if err != nil {
		return nil, err
	}
	return blog, nil
}

// PublishedBlogs is the resolver for the publishedBlogs field.
func (r *queryResolver) PublishedBlogs(ctx context.Context, page *int, pageSize *int, sortBy *string, sortDirection *model.SortDirection) (*model.BlogConnection, error) {
	params := repositories.PaginationParams{
		Page:     1,
		PageSize: 10,
	}

	if page != nil && *page > 0 {
		params.Page = *page
	}
	if pageSize != nil && *pageSize > 0 {
		params.PageSize = *pageSize
	}
	if sortBy != nil {
		params.SortBy = *sortBy
	}
	if sortDirection != nil && *sortDirection == model.SortDirectionDesc {
		params.SortDesc = true
	}

	result, err := r.services.Blog.ListPublishedBlogs(ctx, params)
	if err != nil {
		return nil, err
	}

	// Convert to BlogConnection
	data := make([]*app.Blog, len(result.Data))
	for i, blog := range result.Data {
		data[i] = &blog
	}

	return &model.BlogConnection{
		Data: data,
		Pagination: &model.PaginationInfo{
			Page:       result.Page,
			TotalPages: result.TotalPages,
			Total:      int(result.Total),
			PageSize:   result.PageSize,
		},
	}, nil
}

// BlogsByStatus is the resolver for the blogsByStatus field.
func (r *queryResolver) BlogsByStatus(ctx context.Context, status app.BlogStatus, page *int, pageSize *int, sortBy *string, sortDirection *model.SortDirection) (*model.BlogConnection, error) {
	params := repositories.PaginationParams{
		Page:     1,
		PageSize: 10,
	}

	if page != nil && *page > 0 {
		params.Page = *page
	}
	if pageSize != nil && *pageSize > 0 {
		params.PageSize = *pageSize
	}
	if sortBy != nil {
		params.SortBy = *sortBy
	}
	if sortDirection != nil && *sortDirection == model.SortDirectionDesc {
		params.SortDesc = true
	}

	result, err := r.services.Blog.ListBlogsByStatus(ctx, status, params)
	if err != nil {
		return nil, err
	}

	// Convert to BlogConnection
	data := make([]*app.Blog, len(result.Data))
	for i, blog := range result.Data {
		data[i] = &blog
	}

	return &model.BlogConnection{
		Data: data,
		Pagination: &model.PaginationInfo{
			Page:       result.Page,
			TotalPages: result.TotalPages,
			Total:      int(result.Total),
			PageSize:   result.PageSize,
		},
	}, nil
}

// ID is the resolver for the id field.
func (r *resumeContentResolver) ID(ctx context.Context, obj *app.ResumeContent) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// CategoryID is the resolver for the categoryId field.
func (r *resumeContentResolver) CategoryID(ctx context.Context, obj *app.ResumeContent) (string, error) {
	return strconv.FormatUint(uint64(obj.CategoryID), 10), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *resumeContentResolver) CreatedAt(ctx context.Context, obj *app.ResumeContent) (string, error) {
	return utils.FormatTime(obj.CreatedAt), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *resumeContentResolver) UpdatedAt(ctx context.Context, obj *app.ResumeContent) (string, error) {
	return utils.FormatTime(obj.UpdatedAt), nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *app.User) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// LastLogin is the resolver for the lastLogin field.
func (r *userResolver) LastLogin(ctx context.Context, obj *app.User) (*string, error) {
	return utils.TimeToStringPtr(obj.LastLogin), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *app.User) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *userResolver) UpdatedAt(ctx context.Context, obj *app.User) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// Blog returns generated.BlogResolver implementation.
func (r *Resolver) Blog() generated.BlogResolver { return &blogResolver{r} }

// Category returns generated.CategoryResolver implementation.
func (r *Resolver) Category() generated.CategoryResolver { return &categoryResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Project returns generated.ProjectResolver implementation.
func (r *Resolver) Project() generated.ProjectResolver { return &projectResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// ResumeContent returns generated.ResumeContentResolver implementation.
func (r *Resolver) ResumeContent() generated.ResumeContentResolver { return &resumeContentResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type blogResolver struct{ *Resolver }
type categoryResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type resumeContentResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
